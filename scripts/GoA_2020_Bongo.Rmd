---
title: "GoA 2020 Bongo"
author: "Tim van der Stap"
date: "12/1/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
library(tidyverse)
library(lubridate)
library(worrms)
library(dplyr)
library(obistools)
library(readxl)
library(parsedate)
library(googledrive)
library(here)
```

## Getting started

The following line only needs to be run once to download the tidied data from Google Drive to your computer's hard drive

```{r drive_download}
# Make sure your folder path exists already (e.g. ./POM/raw_data)
drive_download("https://docs.google.com/spreadsheets/d/1DGyFTMc1jUmrKsAnH_17GiAbstMO0uYc/edit#gid=1513148710", path = here("Zooplankton - Bongo", "raw_data", "Bongo.xlsx"), overwrite = TRUE)

drive_download("https://docs.google.com/spreadsheets/d/1q0tGPJSORKEUdfad4ijzO-Ks1JRFbGTg/edit#gid=782668911", path = 
                 here("Zooplankton - Bongo", "raw_data", "Bongo_taxa.xlsx"), overwrite = T)
```

Now we need to read in the `Bongo.xlsx` Excel file and the correct sheets we want to work with. In the Excel file there are two sheets that we want to work with, one that includes metadata information, such as data on tow distance and volume of water filtered, whereas the other sheet includes occurrences of zooplankton in the bongo net used in the isotope/fatty acid analysis. The second file includes data on the community composition or abundance. Three files in total are downloaded and read into three separate data files:

* _bongo2020_metadata_ includes the metadata associated with the 2020 Bongo Zooplankton sampling.
* _bongo2020_data_ includes the dry weight and length measurements from Net 2.
* _bongo2020_taxa_ includes the data for the abundance or community composition study from Net 1. 

``` {r read_file, warning = FALSE}
bongo2020_metadata <- read_excel(here("Zooplankton - Bongo", "raw_data", "Bongo.xlsx"), sheet = "Bongo metadata")
bongo2020_data <- read_excel(here("Zooplankton - Bongo", "raw_data", "Bongo.xlsx"), sheet = "Animal samples")
bongo2020_taxa <- read_excel(here("Zooplankton - Bongo", "raw_data", "Bongo_taxa.xlsx"), sheet = "All data", 
                            col_types = c("text", "date", "date", "numeric", "numeric", "numeric", "text", "numeric", "text", "text", "text", "text", "text", "numeric", "numeric", "numeric", "numeric", "text"))
```

When inspecting the bongo2020_station dataframe, we notice that three sites have been revisited: station P, station 3, and station 4. In the current set up, these stations would get the same `eventID` as the `eventID` for the previous/first visit to these sites, and consequently, it would not be possible for the data user to understand which `eventID` the taxonomic occurrence data is nested under: would this be taxonomic data collected on the first visit, or the second visit?

Fortunately, after discussion with the data provider (N. Mahara), it turns out that the taxonomic occurrence data in these instances _always_ comes from the first visit. Therefore we just have to make some manual adjustments to in the `eventID` to reflect that this is the second visit -- because it is important for the data user to understand that these sites have been revisited.

The next bit of code is ugly and could arguably be replaced / improved:

``` {r, eval = FALSE}
bongo2020_metadata[c(45,46), "Station"] <- "P-2"
bongo2020_metadata[c(69,70), "Station"] <- "4-2"
bongo2020_metadata[c(73,74), "Station"] <- "3-2"
```

Before creating the Event Core, we create the layers for the Event Core. Please note that the time is recorded in _PDT_, so we need to convert that to UTC through the format_iso_8601 function. In the metadata file, the values in the station column have to be changed slightly because they reflect both numbers and characters. When changing them all to characters, numbers are changed to 1.0 instead of 1.

``` {r bongo2020, warning = FALSE}
bongo2020_data[2] <- lapply(bongo2020_data[2], function (x) {
  x1 <- type.convert(as.character(x), as.is = TRUE) 
  ifelse(grepl("^[0-9.]+$", x1), round(as.numeric(x1)), x1)
})

bongo2020 <- bongo2020_data %>% filter(Gear == "Bongo") %>%
  mutate(project = "IYS",
         cruise = paste(project, "GoA2020", sep = ":"),
         station = paste(cruise, Station, sep = ":Stn"),
         cast = paste(station, Net, sep = ":bongo:Net"),
         sample = paste(cast, `Sample ID`, sep = ":"))

bongo2020_metadata[2] <- lapply(bongo2020_metadata[2], function (x) {
  x1 <- type.convert(as.character(x), as.is = TRUE)
  ifelse(grepl("^[0-9.]+$", x1), round(as.numeric(x1)), x1)}
)

bongo2020_metadata <- bongo2020_metadata %>%
  mutate(Time = format(Time, "%H:%M:%S"),
         eventDate = format_iso_8601(as.POSIXct(paste(Date, Time), 
                                                format = "%Y-%m-%d %H:%M:%S",
                                                tz = "America/Los_Angeles")),
         eventDate = str_replace(eventDate, "\\+00:00", "Z"),
         project = "IYS",
         cruise = paste(project, "GoA2020", sep = ":"),
         station = paste(cruise, Station, sep = ":Stn"),
         cast = paste(station, `Net number`, sep = ":bongo:Net"))

bongo2020_metadata$year <- as.numeric(format(as.Date(bongo2020_metadata$eventDate), "%Y"))
bongo2020_metadata$month <- as.numeric(format(as.Date(bongo2020_metadata$eventDate), "%m"))
bongo2020_metadata$day <- as.numeric(format(as.Date(bongo2020_metadata$eventDate), "%d"))
```

## Event Core

The event Core consists of a hierarchical structure with five layers: `project`, `cruise`, `station`, `cast` and `sample`. Each layer has different information associated to it. 

``` {r bongo2020_event}
bongo2020_project <- bongo2020_metadata %>%
  select(eventID = project) %>%
  distinct(eventID) %>%
  mutate(type = "project")

bongo2020_cruise <- bongo2020_metadata %>%
  select(eventID = cruise,
         parentEventID = project) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(type = "cruise")

bongo2020_station <- bongo2020_metadata %>%
  select(eventID = station,
         parentEventID = cruise) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(type = "sampling station")

bongo2020_cast <- bongo2020_metadata %>%
  select(eventID = cast,
         parentEventID = station,
         eventDate,
         year,
         month,
         day,
         decimalLatitude = Latitude,
         decimalLongitude = Longitude,
         maximumDepthInMetres = `Sample depth_m`,
         Notes) %>%
  mutate(minimumDepthInMetres = 0) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(type = "vertical Bongo net cast",
         institutionID = "https://edmo.seadatanet.org/report/2220",
         institutionCode = "UBC-EOAS",
         collectionCode = " ") %>%
  rename(eventRemarks = Notes)

bongo2020_cast <- bongo2020_cast %>%
         mutate(footprintWKT = paste("POINT"," (", bongo2020_cast$decimalLongitude, " ", 
                                     bongo2020_cast$decimalLatitude, ")"))

coordinates <- obistools::calculate_centroid(bongo2020_cast$footprintWKT) %>% select(coordinateUncertaintyInMeters)
bongo2020_cast <- cbind(bongo2020_cast, coordinates)

bongo2020_sample <- bongo2020 %>%
  select(eventID = sample,
         parentEventID = cast) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(type = "sample")

bongo2020_event <- bind_rows(bongo2020_project,
                             bongo2020_cruise,
                             bongo2020_station,
                             bongo2020_cast,
                             bongo2020_sample) %>%
  mutate(geodeticDatum = "WGS84")

# reorder column headers to see if that allows for flattening of the event core:
col_order <- c("eventID", "parentEventID", "eventDate", "year", "month", "day", "decimalLatitude",
               "decimalLongitude", "minimumDepthInMetres", "maximumDepthInMetres", "eventRemarks",
               "institutionID", "institutionCode", "collectionCode", "footprintWKT", "coordinateUncertaintyInMeters",
               "geodeticDatum", "type")
bongo2020_event <- bongo2020_event[, col_order]

# Check to make sure that all parentEventIDs have a corresponding eventID, and then flatten the data:
bongo2020_event <- obistools::flatten_event(bongo2020_event)

# Remove NAs from the Event Core:
bongo2020_event[is.na(bongo2020_event)] <- ""
bongo2020_event <- as.data.frame(bongo2020_event)

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo2020_event, here("Zooplankton - Bongo", "tidy_data", "bongo2020_event.csv"))
drive_upload(here("Zooplankton - Bongo", "tidy_data", "bongo2020_event.csv"),
             path = "https://drive.google.com/drive/u/0/folders/1WgDbGZYDqpDMS7_MSE3JLbviFsUsc-QU",
             name = "bongo2020_eventCore.csv",
             overwrite = TRUE)
```

Now that the event core has been created, next we focus on the occurrence extension. This script contains coding for both the Occurrence extension associated with the abundance/community composition study, and the data collected on species' length and weight. We identify taxa to the lowest common taxonomic rank possible, and if applicable add the common name under `vernacularName` (i.e. Squid). If no taxonomic rank can be assigned to species entry (i.e. `gelatinous spp.`), we contacted the data provider to see if they can provide more taxonomic resolution, otherwise we _did not_ create records of these observations in the Occurrence extension, and therefore associate measurements to the `eventID` rather than an `occurrenceID`.  

Similar to what was done for the 2019 data, we need to ensure that all recorded data have their own row. What I mean by this, is that for some Sample IDs there are numerous length measurements reported, and a number > 1. These have to get their own data entry row, and unique `occurrenceID`.  

Lets first create an Occurrence extension for the (estimated) taxonomic abundance data. The abundance data file also includes data from 2019 so we need to filter out only the data collected during the 2020 High Seas Expedition. Additionally, the `station` column is saved in such a way that the stations are listed as both numbers and character. As the column currently has the class 'character', station numbers are recorded as 1.0 instead of 1. We need to fix this as well. I've confirmed with the data provider (N. Mahara) that abundance/taxonomy data is always from Net 1, unless specified in the comments. 

``` {r bongo2020_taxa_occ, eval = FALSE}
bongo2020_taxa$date <- as.Date(bongo2020_taxa$date)

bongo2020_taxa[1] <- lapply(bongo2020_taxa[1], function (x) {
  x1 <- type.convert(as.character(x), as.is = TRUE)
  ifelse(grepl("^[0-9.]+$", x1), round(as.numeric(x1)), x1)}
)

bongo2020_abun <- subset(bongo2020_taxa, date >= "2020-03-12" & date <= "2020-04-04") %>%
  mutate(Time = format(time, "%H:%M:%S"),
         eventDate = format_iso_8601(as.POSIXct(paste(date, Time),
                                                format = "%Y-%m-%d %H:%M:%S",
                                                tz = "America/Los_Angeles")),
         eventDate = str_replace(eventDate, "\\+00:00", "Z"),
         project = "IYS",
         cruise = paste(project, "GoA2020", sep = ":"),
         station = paste(cruise, station, sep = ":Stn"),
         cast = paste(station, "1", sep = ":bongo:Net"))
```

Manual inspection of this dataframe shows that there are still a few species that will need slight changes in their spelling, as the `worrms` package does not recognize 'sp.' etc. These spelling changes will need to be verified with the data provider to ensure that the correct species is represented. Additionally, some ids contain a life stage (larvae, egg etc). These are also mentioned in a column 'lifestage', so they are removed from the species id. These manual changes are listed below and are not made in the raw data file. This way the original species description is still provided. 

``` {r}
bongo2020_abun$identificationQualifier <- ifelse(grepl("sp.", bongo2020_abun$id), "sp. indet.", NA)

bongo2020_abun$id <- gsub("\\b sp.\\b", "", bongo2020_abun$id)
bongo2020_abun$id <- gsub("egg|nauplius|larva|naplius|calyptopsis|furcillia", "", bongo2020_abun$id)

bongo2020_abun <- bongo2020_abun %>% rename(scientificname = id)
worms_id <- worrms::wm_records_names(unique(bongo2020_abun$scientificname), marine_only = FALSE) %>% dplyr::bind_rows()

# Find out which species are not found in the WoRMS database:
no_worms_id <- left_join(bongo2020_abun, worms_id, by = "scientificname") %>% filter(is.na(AphiaID)) %>% distinct(scientificname)

# These species will need to have their names changed in the original dataframe (bongo2020_abun) which we'll do below. I write this out so it is clear which names or species observations have been altered, so this can be verified. 
bongo2020_abun$scientificname <- gsub("Chaetognath", "Chaetognatha", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Cununidae", "Cuninidae", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Rhynchonereella angellini", "Rhynchonereella angelini",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Disconchoecia elegans", "Discoconchoecia elegans", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Euphausiid ", "Euphausiidae", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Doliolid", "Doliolidae", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Oikopleura labradoriensis", "Oikopleura (Vexillaria) labradoriensis",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Copepod ", "Copepoda", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Mesocalanus tenucornis", "Mesocalanus tenuicornis", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Oikopleura dioica", "Oikopleura (Vexillaria) dioica",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Ophuroidea", "Ophiuroidea", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Scaphocalanus brevicaudatus", "Scaphocalanus brevicornis",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Siphonophore", "Siphonophorae", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Polychaete", "Polychaeta", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Trochophore", " ", bongo2020_abun$scientificname) # this is a lifestage.
bongo2020_abun$scientificname <- gsub("Fish |Fish", "Pisces", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Muggiae atlantica", "Muggiaea atlantica", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Gastropod", "Gastropoda", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Squid", "Teuthida", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Epicarid isopod", "Epicaridea", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Tessarabrachion occulatum", "Tessarabrachion oculatum",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Bivalve", "Bivalvia", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Symbolophorous californiensis", "Symbolophorus californiensis",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Aglama elegans", "Agalma elegans", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Calanoid A", "Calanoida", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Stenobrachius leucropsarus", "Stenobrachius leucopsarus",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Euchirella curticaudata", "Euchirella curticauda", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Nematode", "Nematoda", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Psuedosagitta scrippsae", "Pseudosagitta scrippsae", bongo2020_abun$scientificname)
# Because I changed Chaetognath earlier, it changed the code below which I had to alter. (rewrite this). 
bongo2020_abun$scientificname <- gsub("Chaetognatha sp. (no heads)", "Chaetognatha", bongo2020_abun$scientificname, fixed = TRUE)

# As we have now changed all the names in the original dataframe (bongo2019_abun) to fit the entries in the WoRMS database registry, we can use worrms::wm_records_names() again to find all the taxonomic information. 
bongo2020_worms_id <- worrms::wm_records_names(unique(bongo2020_abun$scientificname), marine_only = FALSE) %>%
  dplyr::bind_rows()

# After manual inspection, there are some AphiaIDs that need to be removed, as the species is listed multiple times.
bongo2020_worms_id <- filter(bongo2020_worms_id, !(AphiaID %in% c("138835", "605966", "534090")))

# Check to see if we missed any:
unique_taxa <- as.data.frame(unique(bongo2020_abun$scientificname))
names(unique_taxa)[1] <- "scientificname"
temp_taxa <- left_join(unique_taxa, bongo2020_worms_id) %>% filter(is.na(AphiaID)) # should be empty.
print(temp_taxa)
```

At time of writing (04-Feb-2021) there is 1 row - for "Trochophore" which still is being dealt with by the data provider. Finally, create the Occurrence extension and save locally and in Google Drive. Merge the `bongo2020_worms_id` dataset back into original dataframe (`bongo2020_abun`), and create `occurrenceIDs`, unique for each row (observation). First remove the column "genus" from `bongo2020_abun`, because otherwise this one is duplicated. 

``` {r}
bongo2020_abun <- bongo2020_abun %>% select(-genus)
bongo2020_abun <- left_join(bongo2020_abun, bongo2020_worms_id, by = "scientificname") %>%
  group_by(cast) %>%
  mutate(id = seq_along(cast)) %>%
  mutate(occurrenceID = paste(cast, id, sep = ":"),
         occurrenceStatus = "present") %>%
  rename(individualCount = ind_counted,
         eventID = cast)

preparations <- bongo2020_metadata %>%
  select(eventID = cast,
         preparations = Preservation)

# Join this column to the bongo2020_abun dataframe
bongo2020_abun_fnl <- left_join(bongo2020_abun, preparations, by = "eventID") %>% distinct() %>%
    select(eventID, stage, sex, scientificname, lsid, identificationQualifier, 
         kingdom, phylum, class, order, family, genus, authority, rank, status, 
         notes, occurrenceID, occurrenceStatus,
         preparations) %>%
  mutate(vernacularName = case_when(scientificname == "Teuthida" ~ "Squid"))

bongo2020_abun_fnl <- bongo2020_abun_fnl %>%
  mutate(specificEpithet = stringr::word(scientificname, 2),
         reproductiveCondition = NA)
```

The second Occurrence extension we create is on the data collected for the dry weight isotope and fatty acid analysis. This data is found in a different data set (`bongo2020`). To deal with these data, we first identify all entries that would not have a WoRMS URN associated to it, and for which no common lowest taxonomic rank can be identified, nor taxonomic resolution be provided by the data provider.

``` {r bongo2020_occ, eval = FALSE}
# Manually inspect the taxa for the isotope/fatty acid analysis
unique(bongo2020$Species)
bongo2020_occ_spp <- bongo2020 %>% filter(!(Species %in% c("Whole net")))
```

Manual inspection of the `bongo2020_occ_spp` dataframe indicates that, although there are some data entries where an alternative species is mentioned in the notes, all of these data entries do have species names associated to them. Therefore we don't have to manually change the species' name for these entries (this was the case for some entries in the 2019 bongo data). Additionally, manual inspection indicated that there are _no_ approximate values in the `Number` column (i.e., ~3, >4). 

Next we confirm that there are currently no duplicate Sample IDs in the dataframe. Once we have that confirmed, we filter for all the data entries where Number > 1 _and_ where no length range is provided. Manual inspection showed that if multiple length_mm measurements are provided, the number of length measurements provided always matched the value in the `Number` column. These entries will either have to separated into their own row with associated lenght/weight measurement. If a length range is provided, these data entries will need a minimumLength and maximumLength associated in the eMOF extension. 

``` {r, eval = FALSE}
bongo2020_occ_spp[duplicated(bongo2020_occ_spp$`Sample ID`),] # no rows in this dataframe = no duplicates.

bongo2020_pre_occ <- bongo2020_occ_spp %>% filter(Number > 1)
bongo2020_occ1 <- bongo2020_pre_occ[grepl(",", bongo2020_pre_occ$Length_mm),] %>%
  mutate(Length_mm = strsplit(Length_mm, ", ")) %>%  unnest(Length_mm) %>%
  group_by(`Sample ID`) %>%
  mutate(count = seq_len(length(`Sample ID`)),
         `Sample ID` = paste(`Sample ID`, count, sep = "-"),
         Number = 1) %>%
  select(-count)

# These two dataframes will be joined, and then merged back into the original dataframe (that was initially subsetted for any data entries where Number > 1). 

bongo2020_occ <- bongo2020_occ_spp[!(bongo2020_occ_spp$`Sample ID` %in% bongo2020_pre_occ1$`Sample ID`),]
bongo2020_occ <- rbind(bongo2020_occ, bongo2020_occ1)
bongo2020_occ <- bongo2020_occ[order(bongo2020_occ$Station),]

bongo2020_occ <- bongo2020_occ %>%
  rename(scientificname = Species,
         individualCount = Number,
         stage = Stage,
         notes = Notes) %>%
  mutate(sex = NA)

preparations <- bongo2020_metadata %>%
  select(cast,
         preparations = Preservation)

# Join this column to the bongo2020_occ dataframe
bongo2020_occ <- left_join(bongo2020_occ, preparations, by = "cast") %>%
  rename(eventID = sample) %>%
  group_by(eventID) %>%
  mutate(id = seq_along(eventID),
         occurrenceID = paste(eventID, id, sep = ":"),
         occurrenceStatus = "present")
```

Next, we start the WoRMS taxon matching procedure. 

- [ ] TO DO: In this analysis, Squid is renamed to Cephalopoda, whereas in the taxonomy analysis we renamed it to Teuthida. Confirm this is correct. 

``` {r}
bongo2020_occ$identificationQualifier <- ifelse(grepl("sp.", bongo2020_occ$scientificname), "sp. indet.", NA)
bongo2020_occ$stage <- ifelse(grepl("egg", bongo2020_occ$scientificname), "egg", NA)

bongo2020_occ$scientificname <- gsub("\\b sp.\\b", "", bongo2020_occ$scientificname) 
worms_id <- worrms::wm_records_names(unique(bongo2020_occ$scientificname), marine_only = FALSE) %>% dplyr::bind_rows()

# Find out which species are not found in the WoRMS database:
no_worms_id <- left_join(bongo2020_occ, worms_id, by = "scientificname") %>% filter(is.na(AphiaID)) %>% distinct(scientificname)

# These species will need to have their names changed in the original dataframe (bongo2020_occ) which we'll do below. I write this out so it is clear which names or species observations have been altered, so this can be verified. 
bongo2020_occ$scientificname <- gsub("Squid", "Cephalopoda", bongo2020_occ$scientificname)
bongo2020_occ$scientificname <- gsub("Fish egg", "Pisces", bongo2020_occ$scientificname)
bongo2020_occ$scientificname <- gsub("Phoronima", "Phronima", bongo2020_occ$scientificname)
bongo2020_occ$scientificname <- gsub("Size fraction", "Animalia", bongo2020_occ$scientificname)

# As we have now changed all the names in the original dataframe (bongo2020_occ) to fit the entries in the WoRMS database registry, we can use worrms::wm_records_names() again to find all the taxonomic information. After manual inspection, there are some AphiaIDs that need to be removed
bongo2020_occ_worms_id <- worrms::wm_records_names(unique(bongo2020_occ$scientificname), marine_only = FALSE) %>%
  dplyr::bind_rows()
bongo2020_occ_worms_id <- bongo2020_occ_worms_id[!grepl("503291", bongo2020_occ_worms_id$AphiaID),]

# Merge this dataframe with the original occurrence dataframe:
bongo2020_occ_fnl <- left_join(bongo2020_occ, bongo2020_occ_worms_id, by = "scientificname")
bongo2020_occ_fnl <- bongo2020_occ_fnl %>% 
  mutate(specificEpithet = stringr::word(scientificname, 2)) %>%
  select(eventID, stage, sex, scientificname, identificationQualifier, kingdom, 
         phylum, class, order, family, genus, specificEpithet, lsid, authority, rank, status,
         preparations, notes, occurrenceID, 
         occurrenceStatus) %>%
  mutate(vernacularName = case_when(
    scientificname == "Cephalopoda" ~ "Squid"),
    reproductiveCondition = NA) %>%
  rename()

bongo2020_occ_ext <- rbind(bongo2020_abun_fnl, bongo2020_occ_fnl) %>%
  rename(scientificName = scientificname,
         scientificNameID = lsid,
         lifeStage = stage,
         scientificNameAuthorship = authority,
         taxonomicStatus = status,
         taxonRank = rank,
         occurrenceRemarks = notes) %>%
  mutate(basisOfRecord = "PreservedSpecimen")

# Reorder by eventID - this at least clusters the eventIDs together. 
bongo2020_occ_ext <- bongo2020_occ_ext[order(gsub("[a-zA-Z]+", "", bongo2020_occ_ext$eventID)),]

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo2020_occ_ext, here("Zooplankton - Bongo", "tidy_data", "bongo2020_occurrence.csv"))
drive_upload(here("Zooplankton - Bongo", "tidy_data", "bongo2020_occurrence.csv"),
             path = "https://drive.google.com/drive/u/0/folders/1WgDbGZYDqpDMS7_MSE3JLbviFsUsc-QU",
             name = "bongo2020_occ_extension.csv",
             overwrite = TRUE)
```

***

## extended measurementOrFact extension

In our extended measurementOrFact extension, we associate the measurements to either the `eventID` (if species does not have an associated WoRMS URN), or the `occurrenceID` (if species has WoRMS URN). Additionally, measurements or facts related to the sampling instrument, sampling method and bottom depth are linked to the `eventID`. It is important that these facts get linked to the correct layer. 

``` {r bongo_bottomdepth, eval = FALSE}
bongo2020_bottomdepth <- bongo2020 %>% 
  select(eventID = cast, 
         Depth_m) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = Depth_m,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementType = recode(measurementType,
                                 Depth_m = "seafloor depth"),
         measurementID = case_when(
    measurementType == "seafloor depth" ~ paste(eventID, "seafloor_depth", sep = ":"))) %>%
  mutate(measurementTypeID = case_when(
    measurementType == "seafloor depth" ~ "http://vocab.nerc.ac.uk/collection/C00/current/SCILOG/"),
        measurementUnit = case_when(
    measurementType == "seafloor depth" ~ "meter"),
        measurementUnitID = case_when(
    measurementUnit == "meter" ~ "http://vocab.nerc.ac.uk/collection/P06/current/ULAA/"),
    measurementValueID = NA) %>%
  select(eventID, measurementID, measurementType, measurementTypeID, measurementValue, measurementValueID,
         measurementUnit, measurementUnitID)
```

Measurements or facts pertaining to the sampling effort are linked in the following chunk of code. The speed of the tow was provided by the data provider, and reported in the Cruise Report. 

``` {r sampling effort, eval = FALSE}
bongo2020_sampling <- bongo2020_meta %>%
  select(eventID = cast, 
         `Tow Distance_m`,
         `Flowmeter Volume Filtered_m3`,
         `Depth estimated Volume filtered_m3`) %>%
  mutate(speed_tow = 1) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = `Tow Distance_m`:speed_tow,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementType = recode(measurementType,
                                 `Tow Distance_m` = "tow_distance",
                                 `Flowmeter Volume Filtered_m3` = "Volume filtered as estimated by flowmeter",
                                 `Depth estimated Volume filtered_m3` = "Volume filtered as estimated by depth-estimate"),
         measurementID = paste(eventID, measurementType, sep = ":"),
         measurementTypeID = case_when(
           measurementType == "tow_distance" ~ "http://vocab.nerc.ac.uk/collection/P01/current/LENTRACK/",
           measurementType == "volume_filtered_flowmeter" ~ "http://vocab.nerc.ac.uk/collection/P09/current/VOLF/", 
           measurementType == "volume_filtered_depth_estimate" ~ " ",
           measurementType == "speed_tow" ~ "http://vocab.nerc.ac.uk/collection/P01/current/TOWSPEED/"
         ),
  measurementUnit = case_when(
    measurementType == "tow_distance" ~ "meter",
    measurementType == "volume_filtered_flowmeter" ~ "cubic meter",
    measurementType == "volume_filtered_depth_estimate" ~ "cubic meter",
    measurementType == "speed_tow" ~ "meter per second"),
  measurementUnitID = case_when(
    measurementUnit == "meter" ~ "http://vocab.nerc.ac.uk/collection/P06/current/ULAA/",
    measurementUnit == "cubic meter" ~ "http://vocab.nerc.ac.uk/collection/P06/current/MCUB/",
    measurementUnit == "meter per second" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UVAA/"),
  measurementValueID = NA) %>%
    select(eventID, measurementID, measurementType, measurementTypeID, measurementValue, measurementValueID,
           measurementUnit, measurementUnitID)
```

Next, add information on the _sampling instrument_. The bongo had a length of 3m, but I couldn't find any controlled vocabulary for sampling instrument length so I omitted this information from the code. Information on the mesh size and sampling instrument opening came from the Cruise Report and is verified by the data provider. 

``` {r samplingInstrument, eval = FALSE}
bongo2020_instrument <- bongo2020_meta %>%
  select(eventID = cast,
         Gear) %>%
  mutate(bongo_mesh = 250,
         bongo_opening = 0.5) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = Gear:bongo_opening,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementID = paste(eventID, "bongo", measurementType, sep = ":"),
         measurementTypeID = case_when(
           measurementType == "Gear" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100002/",
           measurementType == "bongo_mesh" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100015/",
           measurementType == "bongo_opening" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100017/"))

bongo2020_instrument <- bongo2020_instrument %>%
  mutate(measurementUnit = case_when(
           measurementType == "bongo_mesh" ~ "micrometer",
           measurementType == "bongo_opening" ~ "square meter"),
         measurementUnitID = case_when(
           measurementUnit == "micrometer" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UMIC/",
           measurementUnit == "square meter" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UMSQ/"),
         measurementValueID = case_when(
           measurementValue == "Bongo" ~ "http://vocab.nerc.ac.uk/collection/L22/current/NETT0176/")) %>%
  select(eventID, measurementID, measurementType, measurementTypeID, measurementValue,
         measurementValueID, measurementUnit, measurementUnitID)
```

The previous three chunks of code relate to the sampling event. Though it's possible to concatenate the measurementsOrFacts extensions, it's also possible to upload them both separately through the IPT. In this case, one eMOF extension would link back to the `eventID` and the other to `occurrenceID`. Save locally.

``` {r emof_ext_eventID}
bongo2020_eMOF_eventID <- rbind(bongo2020_bottomdepth, bongo2020_sampling, bongo2020_instrument)
write_csv(bongo2020_eMOF_eventID, here("Zooplankton - Bongo", "tidy_data", "bongo2020_eMOF_eventID.csv"))
```

Next, we create the eMOF extension to associate the length and weight measurements to the zooplankton.  

``` {r eMOF, eval = FALSE}
bongo2020_emof <- bongo2020_occ %>%
  select(eventID = cast,
         occurrenceID,
         length = Length_mm,
         weight = Weight_g) %>%
  mutate_all(as.character)
```

Within this dataframe, there are still the data entries that have a length measurements associated to them that's a range (i.e., 15 - 17mm). For these `occurrenceID`s we want to split this column into two, with minimumLength and maximumLength. 

``` {r, eval = FALSE}
range <- bongo2020_emof %>%
  filter(grepl("-", bongo2020_emof$length)) %>%
  separate(col = length, into = c("minimumLength", "maximumLength"), sep = "\\-") %>%
  mutate(length = " ") # required to join dataframes at later stage. 

# Remove any rows from bongo_emof2 where length_mm contains a range, add two dummy columns (minimumLength and maximumLength) and use rbind() to merge `range` with this newly created dataframe.
temp <- bongo2020_emof[ -grep("-", bongo2020_emof$length), ] %>%
  mutate(minimumLength = " ",
         maximumLength = " ")

bongo2020_emof_fnl <- rbind(range, temp)
```

So now we have a dataframe where:
    * Species have been identified to a species or genus level
    * Length measurement ranges have been split up into columns of minimumLength and maximumLength.
    
The following columns of the original raw dataframe are not included in the eMOF extension, but information can still be found in the original dataframe:
* sample_type
* Group
* Size_fraction

``` {r, eval = FALSE}
bongo2020_emof_fnl <- bongo2020_emof_fnl %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = minimumLength:length, ,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementID = case_when(
      measurementType == "length" ~ paste(occurrenceID, "length", sep = ":"),
      measurementType == "weight" ~ paste(occurrenceID, "weight", sep = ":"),
      measurementType == "maximumLength" ~ paste(occurrenceID, "maxLength", sep = ":"),
      measurementType == "minimumLength" ~ paste(occurrenceID, "minLength", sep = ":")),
    measurementTypeID = case_when(
      measurementType == "length" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSINDLX/",
      measurementType == "maximumLength" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSMAXLX/",
      measurementType == "minimumLength" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSMINLX/",
      measurementType == "weight" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600253/"), 
    measurementUnit = case_when(
      measurementType == "length" ~ "millimeter",
      measurementType == "minimumLength" ~ "millimeter",
      measurementType == "maximumLength" ~ "millimeter",
      measurementType == "weight" ~ "grams"), 
    measurementUnitID = case_when(
      measurementUnit == "millimeter" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UXMM/",
      measurementUnit == "grams" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UGRM/"),
    measurementValueID = NA,
    measurementRemarks = NA)
```

Create the eMOF core associated with the community composition or abundance analysis, which are the zooplankton caught in Net 1:

``` {r eMOF Bongo2020 abundance, eval = FALSE}
bongo2020_emof_abun <- bongo2020_abun %>%
  select(eventID,
         occurrenceID, 
         stage, 
         sex, 
         individualCount:abund_m3_depth_est) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = stage:abund_m3_depth_est,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(
    measurementID = case_when(
      measurementType == "stage" ~ paste(occurrenceID, "stage", sep = ":"),
      measurementType == "sex" ~ paste(occurrenceID, "sex", sep = ":"),
      measurementType == "individualCount" ~ paste(occurrenceID, "individualCount", sep = ":"),
      measurementType == "individualTotal" ~ paste(occurrenceID, "individualTotal", sep = ":"),
      measurementType == "abund_m3_flow_est" ~ paste(occurrenceID, "abund_flow", sep = ":"),
      measurementType == "abund_m3_depth_est" ~ paste(occurrenceID, "abund_depth", sep = ":")),
    measurementTypeID = case_when(
      measurementType == "stage" ~ "http://vocab.nerc.ac.uk/collection/P01/current/LSTAGE01/",
      measurementType == "sex" ~ "http://vocab.nerc.ac.uk/collection/P01/current/ENTSEX01/",
      measurementType == "individualCount" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OCOUNT01/",
      measurementType == "individualTotal" ~ " ",
      measurementType == "abund_m3_flow_est" ~ "http://vocab.nerc.ac.uk/collection/P01/current/SDBIOL01/",
      measurementType == "abund_m3_depth_est" ~ "http://vocab.nerc.ac.uk/collection/P01/current/SDBIOL01/"), 
    measurementUnit = case_when(
      measurementType == "individualCount" ~ "individuals",
      measurementType == "individualTotal" ~ "individuals",
      measurementType == "abund_m3_depth_est" ~ "individuals per cubic meter",
      measurementType == "abund_m3_flow_est" ~ "individuals per cubic meter"
    ), 
    measurementUnitID = case_when(
      measurementUnit == "individuals" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UUUU/", 
      measurementUnit == "individuals per cubic meter" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UPMM/"),
    measurementValueID = case_when(
      measurementValue == "M" ~ "http://vocab.nerc.ac.uk/collection/S10/current/S103/",
      measurementValue == "F" ~ "http://vocab.nerc.ac.uk/collection/S10/current/S102/",
      measurementValue == "adult" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1116/", 
      measurementValue == "C6" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1116/",
      measurementValue == "C5" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1112/",
      measurementValue == "C4" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1110/",
      measurementValue == "C3" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S118/",
      measurementValue == "C2" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S117/",
      measurementValue == "C1" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S111/",
      measurementValue == "juvenile" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1127/",
      measurementValue == "calyptopsis" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1118/",
      measurementValue == "egg" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1122/",
      measurementValue == "larva" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1128/",
      measurementValue == "nauplius" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1130/",
      measurementValue == "napulius" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1130/",
      measurementValue == "zoea" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1137/",
      measurementValue == "furcillia" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1123/",
      measurementValue == "neochaete" ~ " ",
      measurementValue == "trochophore" ~ " ",
      measurementValue == "veliger" ~  " ",
      measurementValue == "paralarva" ~ " ",
      measurementValue == "eudoxid" ~ " ",
      measurementValue == "<0.5mm|<1mm" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1152/"
    ), 
    measurementRemarks = case_when(
      measurementValue == "gas float" ~ "Pneumatophore"
    ))

# Check whether gastrozooids and gonozooids (which would be a simplification of s0 life stage), can be commonly listed under: http://vocab.nerc.ac.uk/collection/S11/current/S1138/
```

An eMOF extension can also be created for only those records that are linked to an `occurrenceID`:

``` {r}
bongo2020_eMOF_occID <- rbind(bongo2020_emof_fnl, bongo2020_emof_abun)
write_csv(bongo2020_eMOF_occID, here("Zooplankton - Bongo", "tidy_data", "bongo2020_eMOF_occID.csv"))
```

Create total eMOF extension, and save locally:

``` {r total eMOF extension}
bongo2020_eMOF <- bind_rows(bongo2020_bottomdepth, bongo2020_sampling, bongo2020_instrument,
                            bongo2020_emof_fnl, bongo2020_emof_abun)
# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo2020_eMOF, here("Zooplankton - Bongo", "tidy_data", "bongo2020_eMOF.csv"))
drive_upload(here("Zooplankton - Bongo", "tidy_data", "bongo2020_eMOF.csv"),
             path = "https://drive.google.com/drive/u/0/folders/1WgDbGZYDqpDMS7_MSE3JLbviFsUsc-QU",
             name = "bongo2020_eMOF_extension.csv",
             overwrite = TRUE)
```


